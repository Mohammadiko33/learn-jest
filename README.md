## **Jest در جاوااسکریپت**

### **تعریف**

Jest یک فریم‌ورک تست (Testing Framework) برای جاوااسکریپت است که توسط شرکت **Facebook** توسعه یافته است. این ابزار برای تست برنامه‌های **React** و **Node.js** بسیار محبوب است. هدف Jest این است که توسعه‌دهندگان بتوانند کدهای خود را به‌صورت **خودکار و قابل اعتماد** تست کنند.

### **ویژگی‌های مهم Jest**

1. **آسان برای استفاده:** با دستور ساده می‌توان تست نوشت و اجرا کرد.
2. **شبیه‌سازی (Mocking):** امکان شبیه‌سازی توابع و ماژول‌ها را فراهم می‌کند.
3. **پوشش کد (Code Coverage):** گزارش می‌دهد که چه بخش‌هایی از کد شما تست شده‌اند.
4. **تست واحد و انتگرال:** هم برای تست واحد (Unit Test) و هم برای تست‌های ترکیبی مناسب است.

---

### **نحوه نصب Jest**

برای نصب Jest در پروژه Node.js:

```bash
npm install --save-dev jest
```

در فایل `package.json` می‌توانیم اسکریپت زیر را اضافه کنیم:

```json
"scripts": {
  "test": "jest"
}
```

---

### **مثال ساده**

فرض کنید یک فایل داریم به نام `sum.js`:

```javascript
function sum(a, b) {
  return a + b;
}

module.exports = sum;
```

یک فایل تست به نام `sum.test.js` می‌نویسیم:

```javascript
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

**توضیح کد تست:**

* `test` یک تابع است که یک **توضیح تست** و یک **تابع تست** می‌گیرد.
* `expect` مقداری که برگردانده شده را با **مقدار مورد انتظار** مقایسه می‌کند.
* `toBe` برای مقایسه دقیق استفاده می‌شود.

برای اجرای تست، کافی است دستور زیر را در ترمینال وارد کنید:

```bash
npm test
```

---

### **نتیجه**

Jest باعث می‌شود توسعه‌دهندگان:

* راحت‌تر خطاها را پیدا کنند،
* اطمینان حاصل کنند که تغییرات جدید، کد قبلی را خراب نکرده‌اند،
* و با سرعت بیشتری کد با کیفیت بالا تولید کنند.

---

حتماً! من متن شما را به یک نسخه **ساده، روان و خلاصه** تبدیل کردم:

---

# **انواع تست خودکار در برنامه‌نویسی**

در تست خودکار سه نوع اصلی داریم:

1. **Unit Test (تست واحد)**
2. **Integration Test (تست یکپارچگی)**
3. **End-to-End Test (تست انتها به انتها)**

---

## **1. Unit Test (تست واحد)**

* تمرکز روی **یک بخش کوچک از برنامه** مثل یک تابع یا کلاس است.
* **بدون وابستگی به منابع خارجی** مثل دیتابیس یا API انجام می‌شود.
* اگر تابعی نیاز به داده از بیرون دارد، آن بخش را با **Mock** شبیه‌سازی می‌کنیم.
* **مزیت:** سریع و راحت اجرا می‌شود؛ می‌توان صدها تست را در چند ثانیه اجرا کرد.
* **معایب:** چون منابع خارجی تست نمی‌شوند، **اعتماد کامل نمی‌دهند**.

**خلاصه:** یونیت تست یعنی تست کردن همان بخش کوچک برنامه، بدون اتصال به چیزی خارج از آن.

---

## **2. Integration Test (تست یکپارچگی)**

* برخلاف یونیت تست، این تست **با منابع خارجی واقعی** کار می‌کند، مثل دیتابیس یا سرویس‌های دیگر.
* **زمان‌برتر** است، چون نیاز به خواندن و نوشتن داده از منابع واقعی دارد.
* **مزیت:** اعتماد بیشتری نسبت به عملکرد واقعی برنامه می‌دهد.
* نکته مهم: فقط داشتن چند کلاس باهم کافی نیست؛ شرط این تست **ارتباط با منابع خارجی** است.

---

## **3. End-to-End Test (تست انتها به انتها)**

* برنامه را **از طریق رابط کاربری واقعی** تست می‌کند، درست مثل یک کاربر واقعی.
* شامل بالا آوردن برنامه، ورود اطلاعات، احراز هویت، پر کردن فرم‌ها و دریافت نتیجه است.
* **بیشترین اعتماد را دارد**، اما **خیلی زمان‌بر است**.
* معمولاً با ابزارها و افزونه‌های مخصوص تست رابط کاربری انجام می‌شود.

---

# **چه زمانی از هر نوع تست استفاده کنیم؟**

* **Unit Test (تست واحد):**

  * مناسب برای **منطق برنامه** است.
  * برای بررسی **شرط‌ها، حلقه‌ها و الگوریتم‌های پیچیده** بسیار خوب عمل می‌کند.
  * اگر بخشی از برنامه دارای **منطق الگوریتمی** است، حتماً باید با یونیت تست پوشش داده شود.

* **Integration Test (تست یکپارچگی):**

  * برای بخش‌هایی که الگوریتم خاصی ندارند،
  * یا فقط **خواندن/نوشتن اطلاعات از دیتابیس** انجام می‌دهند،
  * استفاده می‌شود.
  * این تست باعث اطمینان از عملکرد واقعی با منابع خارجی می‌شود.

* **End-to-End Test (تست انتها به انتها):**

  * برای اطمینان بیشتر، می‌توان **مقداری E2E** هم اضافه کرد.
  * این تست تضمین می‌کند برنامه در **کل مسیر واقعی** درست کار می‌کند.

**خلاصه:**

> الگوریتم‌ها → یونیت تست

> دیتابیس و منابع خارجی → اینترگریشن تست

> مسیر کامل کاربر → اند تو اند تست

---

حتماً! اول یک توضیح ساده درباره‌ی تستی که نوشتی می‌دهم و بعد متدهای آخر را با مثال کوتاه و ساده شرح می‌دهم.

---


```javascript
const gte = require("../app")
```

این خط تابع `gte` را از فایل `app.js` وارد می‌کند.

```javascript
test("gte - should return true if a is grater than b", () => {
    const res = gte(10,9);
    expect(9).toBe(8);
});
```

* `test` یک تست جدید تعریف می‌کند.
* `expect` برای **مقایسه نتیجه واقعی با مقدار مورد انتظار** استفاده می‌شود.
* نکته: در اینجا مقادیر `expect(9).toBe(8)` و `expect(6).toBe(7)` اشتباه هستند، چون همیشه **این تست‌ها شکست می‌خورند**. درستش باید مثل این باشد:

```javascript
expect(res).toBe(true);  // وقتی 10 >= 9
```

---

## **متدهای Jest و مثال ساده**

### 1. `.toBeNull()`

چک می‌کند مقدار **null** باشد.

```javascript
expect(null).toBeNull();
```

### 2. `.toBeUndefined()`

چک می‌کند مقدار **undefined** باشد.

```javascript
let a;
expect(a).toBeUndefined();
```

### 3. `.toBeDefined()`

چک می‌کند مقدار **تعریف شده** باشد (نه undefined).

```javascript
let a = 5;
expect(a).toBeDefined();
```

### 4. `.toBeTruthy()`

چک می‌کند مقدار **در شرط if درست** باشد.

```javascript
expect(true).toBeTruthy();
expect(1).toBeTruthy();
```

### 5. `.toBeFalsy()`

چک می‌کند مقدار **در شرط if غلط** باشد.

```javascript
expect(false).toBeFalsy();
expect(0).toBeFalsy();
```

### 6. `.toBeGreaterThan(number)`

چک می‌کند مقدار بزرگ‌تر از عدد داده شده باشد.

```javascript
expect(10).toBeGreaterThan(5);
```

### 7. `.toBeGreaterThanOrEqual(number)`

چک می‌کند مقدار **بزرگ‌تر یا مساوی** عدد باشد.

```javascript
expect(10).toBeGreaterThanOrEqual(10);
```

### 8. `.toBeLessThan(number)`

چک می‌کند مقدار کوچک‌تر از عدد باشد.

```javascript
expect(5).toBeLessThan(10);
```

### 9. `.toBeLessThanOrEqual(number)`

چک می‌کند مقدار **کمتر یا مساوی** عدد باشد.

```javascript
expect(5).toBeLessThanOrEqual(5);
```

### 10. `.toBeCloseTo(number, numDigits?)`

چک می‌کند مقدار **تقریباً برابر** عدد باشد (برای اعداد اعشاری).

```javascript
expect(0.1 + 0.2).toBeCloseTo(0.3);
```

---

خیلی عالی پیش رفتی 👌
الان داری از چند تابع (`gte`, `welcomeMessage`, `shoppingList`, `getUser`) استفاده می‌کنی و برای هرکدوم **تست‌های یونیت** نوشتی.
من تغییرات و نکاتی که در کدت هست را مرحله‌به‌مرحله توضیح می‌دم و متدهای آخر (`.toEqual`, `.toMatchObject`, `.toHaveProperty`) رو هم آموزش می‌دم.

---

## 1. **تغییر از `test` به `describe/it`**

```js
describe("gte", () => {
  it("should return true if a is greater than b", () => {
    const res = gte(10, 9);
    expect(res).toBe(true);
  });
});
```

* `describe` برای **گروه‌بندی تست‌ها** استفاده میشه. (مثل یک پوشه برای هر بخش کد)
* `it` مشابه `test` هست، ولی خوانایی بیشتری به تست میده.
  یعنی "it should return true ..." میشه یک جمله کامل.

---

## 2. **تست تابع `gte`**

```js
function gte(num1, num2) {
  return num1 >= num2 ? true : false;
}
```

* این تابع ساده‌تر شده (با **عملگر سه‌تایی**) و خروجی فقط `true` یا `false` هست.
* تست‌ها بررسی می‌کنن آیا **بزرگتر** یا **کوچکتر** درست عمل می‌کنه.

---

## 3. **تست تابع `welcomeMessage`**

```js
const welcomeMessage = (name) => `Hello ${name}. welcome to jest tutoral`;

it("should return a welcome message containing the name", () => {
  const res = welcomeMessage("Mohammad");
  expect(res).toContain("Mohammad"); 
});
```

* اینجا از **`.toContain`** استفاده کردی.
* `.toContain` چک می‌کنه رشته یا آرایه شامل مقدار مورد نظر باشه.
* خوب برای تست متن‌های داینامیک (مثل اسم کاربر) استفاده میشه.

---

## 4. **تست تابع `shoppingList`**

```js
function shoppingList() {
  return ["diseart", "cake", "cupcake"];
}

it("array coffe shop", () => {
  const result = shoppingList();
  expect(result).toContain("cupcake");
});
```

* این تست بررسی می‌کنه آرایه شامل `"cupcake"` باشه.
* باز هم **`.toContain`** اینجا به کار اومده برای چک کردن وجود مقدار داخل آرایه.

---

## 5. **تست تابع `getUser`**

```js
function getUser(){
  return {
    id: 1,
    name: "mohammad"
  }
}
```

اینجا یک نکته مهم هست ⬇️
تو نوشتی:

```js
expect(res).toBe({
  id: 1,
  name: "mohammad",
});
```

❌ ولی `.toBe` برای مقایسه **مقادیر ساده (primitive)** مثل عدد و رشته هست.
برای مقایسه **آبجکت‌ها یا آرایه‌ها** باید از `.toEqual` استفاده کنی.

✅ درستش این میشه:

```js
expect(res).toEqual({
  id: 1,
  name: "mohammad"
});
```

---

## 6. **متدهای جدید Jest**

### 🔹 `.toEqual(object)`

برای مقایسه **آبجکت یا آرایه** به‌طور کامل.

```js
expect(getUser()).toEqual({ id: 1, name: "mohammad" });
```

---

### 🔹 `.toMatchObject(partialObject)`

برای وقتی که فقط می‌خوای بخشی از آبجکت رو چک کنی.

```js
expect(getUser()).toMatchObject({ name: "mohammad" });
```

اینجا فقط وجود کلید `name` با مقدار `"mohammad"` بررسی میشه و نیازی نیست همه‌ی آبجکت برابر باشه.

---

### 🔹 `.toHaveProperty(key, value?)`

برای بررسی اینکه یک آبجکت **فلان پراپرتی** رو داره یا نه.

```js
expect(getUser()).toHaveProperty("id"); 
expect(getUser()).toHaveProperty("name", "mohammad");
```

---

✅ پس بهتره تست `getUser` رو اینطوری بازنویسی کنیم:

```js
describe("get user", () => {
  it("should return user object", () => {
    const res = getUser();
    expect(res).toEqual({ id: 1, name: "mohammad" }); // مقایسه کامل
    expect(res).toMatchObject({ name: "mohammad" }); // مقایسه بخشی
    expect(res).toHaveProperty("id", 1); // بررسی وجود پراپرتی
  });
});
```

---

### 🔑 خلاصه تغییرات:

* `describe/it` → گروه‌بندی و خوانایی بهتر تست‌ها.
* `.toBe` → برای مقایسه مقادیر ساده.
* `.toEqual` → برای مقایسه آبجکت/آرایه.
* `.toMatchObject` → وقتی فقط بخشی از آبجکت مهمه.
* `.toHaveProperty` → وقتی فقط می‌خوای وجود یک کلید (با یا بدون مقدار) رو چک کنی.
* `.toContain` → برای بررسی وجود یک مقدار داخل رشته یا آرایه.

---

می‌خوای برات یه **جدول خلاصه از همه Matcherهای Jest که تا اینجا یاد گرفتی** درست کنم (با مثال کوچیک کنار هرکدوم)؟