## **Jest در جاوااسکریپت**

### **تعریف**

Jest یک فریم‌ورک تست (Testing Framework) برای جاوااسکریپت است که توسط شرکت **Facebook** توسعه یافته است. این ابزار برای تست برنامه‌های **React** و **Node.js** بسیار محبوب است. هدف Jest این است که توسعه‌دهندگان بتوانند کدهای خود را به‌صورت **خودکار و قابل اعتماد** تست کنند.

### **ویژگی‌های مهم Jest**

1. **آسان برای استفاده:** با دستور ساده می‌توان تست نوشت و اجرا کرد.
2. **شبیه‌سازی (Mocking):** امکان شبیه‌سازی توابع و ماژول‌ها را فراهم می‌کند.
3. **پوشش کد (Code Coverage):** گزارش می‌دهد که چه بخش‌هایی از کد شما تست شده‌اند.
4. **تست واحد و انتگرال:** هم برای تست واحد (Unit Test) و هم برای تست‌های ترکیبی مناسب است.

---

### **نحوه نصب Jest**

برای نصب Jest در پروژه Node.js:

```bash
npm install --save-dev jest
```

در فایل `package.json` می‌توانیم اسکریپت زیر را اضافه کنیم:

```json
"scripts": {
  "test": "jest"
}
```

---

### **مثال ساده**

فرض کنید یک فایل داریم به نام `sum.js`:

```javascript
function sum(a, b) {
  return a + b;
}

module.exports = sum;
```

یک فایل تست به نام `sum.test.js` می‌نویسیم:

```javascript
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

**توضیح کد تست:**

* `test` یک تابع است که یک **توضیح تست** و یک **تابع تست** می‌گیرد.
* `expect` مقداری که برگردانده شده را با **مقدار مورد انتظار** مقایسه می‌کند.
* `toBe` برای مقایسه دقیق استفاده می‌شود.

برای اجرای تست، کافی است دستور زیر را در ترمینال وارد کنید:

```bash
npm test
```

---

### **نتیجه**

Jest باعث می‌شود توسعه‌دهندگان:

* راحت‌تر خطاها را پیدا کنند،
* اطمینان حاصل کنند که تغییرات جدید، کد قبلی را خراب نکرده‌اند،
* و با سرعت بیشتری کد با کیفیت بالا تولید کنند.

---

حتماً! من متن شما را به یک نسخه **ساده، روان و خلاصه** تبدیل کردم:

---

# **انواع تست خودکار در برنامه‌نویسی**

در تست خودکار سه نوع اصلی داریم:

1. **Unit Test (تست واحد)**
2. **Integration Test (تست یکپارچگی)**
3. **End-to-End Test (تست انتها به انتها)**

---

## **1. Unit Test (تست واحد)**

* تمرکز روی **یک بخش کوچک از برنامه** مثل یک تابع یا کلاس است.
* **بدون وابستگی به منابع خارجی** مثل دیتابیس یا API انجام می‌شود.
* اگر تابعی نیاز به داده از بیرون دارد، آن بخش را با **Mock** شبیه‌سازی می‌کنیم.
* **مزیت:** سریع و راحت اجرا می‌شود؛ می‌توان صدها تست را در چند ثانیه اجرا کرد.
* **معایب:** چون منابع خارجی تست نمی‌شوند، **اعتماد کامل نمی‌دهند**.

**خلاصه:** یونیت تست یعنی تست کردن همان بخش کوچک برنامه، بدون اتصال به چیزی خارج از آن.

---

## **2. Integration Test (تست یکپارچگی)**

* برخلاف یونیت تست، این تست **با منابع خارجی واقعی** کار می‌کند، مثل دیتابیس یا سرویس‌های دیگر.
* **زمان‌برتر** است، چون نیاز به خواندن و نوشتن داده از منابع واقعی دارد.
* **مزیت:** اعتماد بیشتری نسبت به عملکرد واقعی برنامه می‌دهد.
* نکته مهم: فقط داشتن چند کلاس باهم کافی نیست؛ شرط این تست **ارتباط با منابع خارجی** است.

---

## **3. End-to-End Test (تست انتها به انتها)**

* برنامه را **از طریق رابط کاربری واقعی** تست می‌کند، درست مثل یک کاربر واقعی.
* شامل بالا آوردن برنامه، ورود اطلاعات، احراز هویت، پر کردن فرم‌ها و دریافت نتیجه است.
* **بیشترین اعتماد را دارد**، اما **خیلی زمان‌بر است**.
* معمولاً با ابزارها و افزونه‌های مخصوص تست رابط کاربری انجام می‌شود.

---

# **چه زمانی از هر نوع تست استفاده کنیم؟**

* **Unit Test (تست واحد):**

  * مناسب برای **منطق برنامه** است.
  * برای بررسی **شرط‌ها، حلقه‌ها و الگوریتم‌های پیچیده** بسیار خوب عمل می‌کند.
  * اگر بخشی از برنامه دارای **منطق الگوریتمی** است، حتماً باید با یونیت تست پوشش داده شود.

* **Integration Test (تست یکپارچگی):**

  * برای بخش‌هایی که الگوریتم خاصی ندارند،
  * یا فقط **خواندن/نوشتن اطلاعات از دیتابیس** انجام می‌دهند،
  * استفاده می‌شود.
  * این تست باعث اطمینان از عملکرد واقعی با منابع خارجی می‌شود.

* **End-to-End Test (تست انتها به انتها):**

  * برای اطمینان بیشتر، می‌توان **مقداری E2E** هم اضافه کرد.
  * این تست تضمین می‌کند برنامه در **کل مسیر واقعی** درست کار می‌کند.

**خلاصه:**

> الگوریتم‌ها → یونیت تست

> دیتابیس و منابع خارجی → اینترگریشن تست

> مسیر کامل کاربر → اند تو اند تست

---

حتماً! اول یک توضیح ساده درباره‌ی تستی که نوشتی می‌دهم و بعد متدهای آخر را با مثال کوتاه و ساده شرح می‌دهم.

---


```javascript
const gte = require("../app")
```

این خط تابع `gte` را از فایل `app.js` وارد می‌کند.

```javascript
test("gte - should return true if a is grater than b", () => {
    const res = gte(10,9);
    expect(9).toBe(8);
});
```

* `test` یک تست جدید تعریف می‌کند.
* `expect` برای **مقایسه نتیجه واقعی با مقدار مورد انتظار** استفاده می‌شود.
* نکته: در اینجا مقادیر `expect(9).toBe(8)` و `expect(6).toBe(7)` اشتباه هستند، چون همیشه **این تست‌ها شکست می‌خورند**. درستش باید مثل این باشد:

```javascript
expect(res).toBe(true);  // وقتی 10 >= 9
```

---

## **متدهای Jest و مثال ساده**

### 1. `.toBeNull()`

چک می‌کند مقدار **null** باشد.

```javascript
expect(null).toBeNull();
```

### 2. `.toBeUndefined()`

چک می‌کند مقدار **undefined** باشد.

```javascript
let a;
expect(a).toBeUndefined();
```

### 3. `.toBeDefined()`

چک می‌کند مقدار **تعریف شده** باشد (نه undefined).

```javascript
let a = 5;
expect(a).toBeDefined();
```

### 4. `.toBeTruthy()`

چک می‌کند مقدار **در شرط if درست** باشد.

```javascript
expect(true).toBeTruthy();
expect(1).toBeTruthy();
```

### 5. `.toBeFalsy()`

چک می‌کند مقدار **در شرط if غلط** باشد.

```javascript
expect(false).toBeFalsy();
expect(0).toBeFalsy();
```

### 6. `.toBeGreaterThan(number)`

چک می‌کند مقدار بزرگ‌تر از عدد داده شده باشد.

```javascript
expect(10).toBeGreaterThan(5);
```

### 7. `.toBeGreaterThanOrEqual(number)`

چک می‌کند مقدار **بزرگ‌تر یا مساوی** عدد باشد.

```javascript
expect(10).toBeGreaterThanOrEqual(10);
```

### 8. `.toBeLessThan(number)`

چک می‌کند مقدار کوچک‌تر از عدد باشد.

```javascript
expect(5).toBeLessThan(10);
```

### 9. `.toBeLessThanOrEqual(number)`

چک می‌کند مقدار **کمتر یا مساوی** عدد باشد.

```javascript
expect(5).toBeLessThanOrEqual(5);
```

### 10. `.toBeCloseTo(number, numDigits?)`

چک می‌کند مقدار **تقریباً برابر** عدد باشد (برای اعداد اعشاری).

```javascript
expect(0.1 + 0.2).toBeCloseTo(0.3);
```

---

خیلی عالی پیش رفتی 👌
الان داری از چند تابع (`gte`, `welcomeMessage`, `shoppingList`, `getUser`) استفاده می‌کنی و برای هرکدوم **تست‌های یونیت** نوشتی.
من تغییرات و نکاتی که در کدت هست را مرحله‌به‌مرحله توضیح می‌دم و متدهای آخر (`.toEqual`, `.toMatchObject`, `.toHaveProperty`) رو هم آموزش می‌دم.

---

## 1. **تغییر از `test` به `describe/it`**

```js
describe("gte", () => {
  it("should return true if a is greater than b", () => {
    const res = gte(10, 9);
    expect(res).toBe(true);
  });
});
```

* `describe` برای **گروه‌بندی تست‌ها** استفاده میشه. (مثل یک پوشه برای هر بخش کد)
* `it` مشابه `test` هست، ولی خوانایی بیشتری به تست میده.
  یعنی "it should return true ..." میشه یک جمله کامل.

---

## 2. **تست تابع `gte`**

```js
function gte(num1, num2) {
  return num1 >= num2 ? true : false;
}
```

* این تابع ساده‌تر شده (با **عملگر سه‌تایی**) و خروجی فقط `true` یا `false` هست.
* تست‌ها بررسی می‌کنن آیا **بزرگتر** یا **کوچکتر** درست عمل می‌کنه.

---

## 3. **تست تابع `welcomeMessage`**

```js
const welcomeMessage = (name) => `Hello ${name}. welcome to jest tutoral`;

it("should return a welcome message containing the name", () => {
  const res = welcomeMessage("Mohammad");
  expect(res).toContain("Mohammad"); 
});
```

* اینجا از **`.toContain`** استفاده کردی.
* `.toContain` چک می‌کنه رشته یا آرایه شامل مقدار مورد نظر باشه.
* خوب برای تست متن‌های داینامیک (مثل اسم کاربر) استفاده میشه.

---

## 4. **تست تابع `shoppingList`**

```js
function shoppingList() {
  return ["diseart", "cake", "cupcake"];
}

it("array coffe shop", () => {
  const result = shoppingList();
  expect(result).toContain("cupcake");
});
```

* این تست بررسی می‌کنه آرایه شامل `"cupcake"` باشه.
* باز هم **`.toContain`** اینجا به کار اومده برای چک کردن وجود مقدار داخل آرایه.

---

## 5. **تست تابع `getUser`**

```js
function getUser(){
  return {
    id: 1,
    name: "mohammad"
  }
}
```

اینجا یک نکته مهم هست ⬇️
تو نوشتی:

```js
expect(res).toBe({
  id: 1,
  name: "mohammad",
});
```

❌ ولی `.toBe` برای مقایسه **مقادیر ساده (primitive)** مثل عدد و رشته هست.
برای مقایسه **آبجکت‌ها یا آرایه‌ها** باید از `.toEqual` استفاده کنی.

✅ درستش این میشه:

```js
expect(res).toEqual({
  id: 1,
  name: "mohammad"
});
```

---

## 6. **متدهای جدید Jest**

### 🔹 `.toEqual(object)`

برای مقایسه **آبجکت یا آرایه** به‌طور کامل.

```js
expect(getUser()).toEqual({ id: 1, name: "mohammad" });
```

---

### 🔹 `.toMatchObject(partialObject)`

برای وقتی که فقط می‌خوای بخشی از آبجکت رو چک کنی.

```js
expect(getUser()).toMatchObject({ name: "mohammad" });
```

اینجا فقط وجود کلید `name` با مقدار `"mohammad"` بررسی میشه و نیازی نیست همه‌ی آبجکت برابر باشه.

---

### 🔹 `.toHaveProperty(key, value?)`

برای بررسی اینکه یک آبجکت **فلان پراپرتی** رو داره یا نه.

```js
expect(getUser()).toHaveProperty("id"); 
expect(getUser()).toHaveProperty("name", "mohammad");
```

---

✅ پس بهتره تست `getUser` رو اینطوری بازنویسی کنیم:

```js
describe("get user", () => {
  it("should return user object", () => {
    const res = getUser();
    expect(res).toEqual({ id: 1, name: "mohammad" }); // مقایسه کامل
    expect(res).toMatchObject({ name: "mohammad" }); // مقایسه بخشی
    expect(res).toHaveProperty("id", 1); // بررسی وجود پراپرتی
  });
});
```

---

### 🔑 خلاصه تغییرات:

* `describe/it` → گروه‌بندی و خوانایی بهتر تست‌ها.
* `.toBe` → برای مقایسه مقادیر ساده.
* `.toEqual` → برای مقایسه آبجکت/آرایه.
* `.toMatchObject` → وقتی فقط بخشی از آبجکت مهمه.
* `.toHaveProperty` → وقتی فقط می‌خوای وجود یک کلید (با یا بدون مقدار) رو چک کنی.
* `.toContain` → برای بررسی وجود یک مقدار داخل رشته یا آرایه.

---

### ۱. تغییر در فانکشن‌ها

تو یه فانکشن جدید به اسم **`login`** اضافه کردی:

```js
const login = (password) => 
  password === "1234" 
    ? { jwt: "GY@(YE(*@Y(!E*(&^!^E*&!^@E" } 
    : false
```

این فانکشن میگه:

* اگه پسورد درست باشه (`1234`)، یه **آبجکت** شامل jwt برمی‌گردونه.
* اگه پسورد غلط باشه، مقدار **false** برمی‌گردونه.

---

### ۲. تغییر در تست **get user**

قبلاً فقط `expect(res)` نوشته بودی .
الان اینطوری تغییرش دادی:

```js
expect(res).toHaveProperty("name", "mohammad");
```

🔹 این دقیقاً چک می‌کنه که خروجی `getUser()`
یک property به اسم `name` با مقدار `"mohammad"` داشته باشه.
این خیلی بهتر و دقیق‌تر از قبلیه ✅

---

### ۳. چرا دوتا `it` نوشتی؟

در تست **login** دو حالت مختلف باید بررسی بشه:

1. وقتی پسورد اشتباهه → باید خطا یا نتیجه‌ی مناسب بده.

   ```js
   it("should throw an error if password is wrong", () => {
     expect(() => login("1235")).toThrow()
   });
   ```

2. وقتی پسورد درسته → باید jwt برگردونه.

   ```js
   it("should return jwt if password is correct", () => {
     const res = login("1234");
     expect(res).toHaveProperty("jwt");
   });
   ```

🔹 دلیلش اینه که **هر تست (`it`) فقط باید یک رفتار مشخص رو تست کنه**.
اگر همه‌چی رو توی یک `it` بنویسی، وقتی یکی از شرط‌ها fail بشه، مشخص نیست مشکل از کجاست.


----
---

## 1. ساختار پروژه

تو این مرحله یه پروژه‌ی خیلی ساده با **۳ لایه** نوشتی:

1. **service.js** → لایه‌ی سرویس (کار با دیتا، مثل گرفتن کاربر از دیتابیس یا ارسال ایمیل)
2. **app.js** → لایه‌ی اپلیکیشن (منطق اصلی، مثل حساب کردن تخفیف)
3. **test/app.test.js** → لایه‌ی تست (با استفاده از Jest منطق رو تست می‌کنی)

این معماری دقیقا شبیه پروژه‌های واقعی دنیای وب هست.

---

## 2. فانکشن getUserById

```js
function getUserById(id) {
  console.log(`reading data from db with ${id} id`);
  const users = [
    { id: 1, name: "mohammad", purchasesCount: 5 },
    { id: 2, name: "amir", purchasesCount: 4 },
    { id: 3, name: "reza", purchasesCount: 6 },
  ];
  const data = users.find((item) => item.id === id);
  if (data) return data;
  throw new Error(`no user with id ${id}`);
}
```

### چه کار می‌کنه؟

* یه لیست از کاربران فرضی داره (مثل دیتابیس کوچیک).
* دنبال کاربری می‌گرده که id برابر با ورودی باشه.
* اگر پیدا شد → همون کاربر رو برمی‌گردونه.
* اگر پیدا نشد → یه خطا (Error) پرتاب می‌کنه.

👉 این یعنی هر وقت بخوای اطلاعات یه کاربر رو با id بگیری، این تابع رو صدا می‌زنی.

---

## 3. فانکشن sendEmail

```js
function sendEmail(name, email) {
  console.log(`username: ${name} , email : ${email} sent!`);
}
```

### چه کار می‌کنه؟

* خیلی ساده فقط یه **log** میزنه، میگه: فلان ایمیل برای فلان کاربر فرستاده شد.
* توی پروژه واقعی اینجا قراره سرویس ایمیل صدا زده بشه (ولی فعلا شبیه‌سازیه).

---

## 4. فانکشن calculateDiscount

```js
function calculateDiscount(id) {
  let discount = 0;
  const { purchasesCount, name } = getUserById(id);
  if (purchasesCount > 3) return 10;

  sendEmail(name, `you have got %${discount} percent discount`);
  return discount;
}
```

### چه کار می‌کنه؟

* یه id کاربر می‌گیره.
* اطلاعات کاربر رو از `getUserById` می‌گیره.
* شرط می‌ذاره:

  * اگه تعداد خرید (`purchasesCount`) بیشتر از ۳ باشه → تخفیف `10` برگردون.
  * در غیر این صورت → ایمیل بزن (با درصد تخفیف صفر) و تخفیف `0` برگردون.

👉 این تابع دقیقا **منطق کسب‌وکار (Business Logic)** رو پیاده‌سازی می‌کنه.

---

## 5. چرا تست می‌نویسیم؟

هدف تست اینه که مطمئن بشی کدی که نوشتی درست کار می‌کنه، بدون اینکه واقعا ایمیل بفرسته یا به دیتابیس وصل بشه.
اینجاست که **mock کردن (شبیه‌سازی کردن)** به کار میاد.

---

## 6. تست اول

```js
it("should return 10 if user has more than 3 purchases", () => {
  getUserById.mockReturnValue({ id: 4, name: "john", purchasesCount: 7 });
  expect(calculateDiscount(4)).toBe(10);
});
```

### چه کار می‌کنه؟

* تابع `getUserById` رو **mock** کردی، یعنی دیگه واقعا از دیتابیس نخونه، فقط برگردونه:

  ```js
  { id: 4, name: "john", purchasesCount: 7 }
  ```
* بعد `calculateDiscount(4)` رو صدا زدی.
* چون خریدها (`7`) بیشتر از ۳ هستن → خروجی باید `10` باشه.
* تست همینو انتظار داره (`toBe(10)`).

👉 نتیجه: این تست داره **سناریو تخفیف گرفتن** رو بررسی می‌کنه.

---

## 7. تست دوم

```js
it("should return 0 and send email if user has 3 or fewer purchases", () => {
  getUserById.mockReturnValue({ id: 4, name: "john", purchasesCount: 2 });

  const result = calculateDiscount(4);

  expect(result).toBe(0);
  expect(sendEmail).toHaveBeenCalled();
  expect(sendEmail.mock.calls[0][0]).toBe("john");
  expect(sendEmail.mock.calls[0][1]).toContain("0 percent");
});
```

### چه کار می‌کنه؟

* باز هم `getUserById` رو mock کردی، ولی این بار برگردوندی:

  ```js
  { id: 4, name: "john", purchasesCount: 2 }
  ```
* چون خریدها (`2`) کمتر از ۳ هستن → تخفیف باید `0` باشه.
* علاوه بر این، تابع باید ایمیل بزنه:

  * تست چک می‌کنه `sendEmail` صدا زده شده.
  * آرگومان اول (`name`) باید `"john"` باشه.
  * آرگومان دوم (`email message`) باید شامل `"0 percent"` باشه.

👉 نتیجه: این تست داره **سناریو تخفیف نگرفتن** رو بررسی می‌کنه.

---

## 8. نکته مهم در این اپیزود

* **Mock کردن** باعث شد وابستگی به دیتابیس و ایمیل واقعی رو حذف کنیم.
* تست‌هامون فقط منطق اصلی رو چک می‌کنن.
* هر `it` یه سناریوی مستقل رو تست می‌کنه (خیلی مهمه برای خوانایی و دیباگ).

---

## 📌 خلاصه‌ی خیلی ساده

* `getUserById`: کاربر رو از دیتابیس فرضی برمی‌گردونه.
* `sendEmail`: ایمیل فرضی می‌فرسته.
* `calculateDiscount`: منطق تخفیف → بیشتر از ۳ خرید = ۱۰٪ تخفیف، وگرنه ایمیل با ۰٪.
* توی تست‌ها → دیتابیس و ایمیل رو **mock** کردی که واقعی اجرا نشن و فقط نتیجه رو تست کنی.

---
---

## 🎬 اپیزود: Calculator Class

### 1. چرا کلاس؟

تا اینجا بیشتر با فانکشن کار می‌کردیم (مثل `getUserById` یا `calculateDiscount`).
ولی وقتی چندتا رفتار (operation) به هم مرتبط باشن، بهتره همه‌شون رو توی یک **کلاس** جمع کنیم.
اینجا `Calculator` یه **ماشین حساب ساده**ه که:

* دو تا عدد (`a` و `b`) می‌گیره.
* چهار عمل اصلی (جمع، تفریق، ضرب، تقسیم) رو روی اون‌ها انجام میده.

---

### 2. کد کلاس

```js
class Calculator {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }

  add() {
    return this.a + this.b;
  }
  sub() {
    return this.a - this.b;
  }
  div() {
    return this.a / this.b;
  }
  mul() {
    return this.a * this.b;
  }
}
```

* `constructor(a,b)` → وقتی نمونه (instance) می‌سازی، این دو تا عدد ذخیره میشن.
* `add()` → جمع
* `sub()` → تفریق
* `div()` → تقسیم
* `mul()` → ضرب

اینجوری توی پروژه‌های واقعی می‌تونی کلاس رو بارها استفاده کنی، بدون تکرار کد.

---

### 3. نوشتن تست‌ها

توی تست‌ها یه نمونه از کلاس می‌سازیم:

```js
let calculator;
beforeEach(() => {
  calculator = new Calculator(10, 5);
});
```

👉 حالا می‌تونیم تمام متدها رو روی همون instance تست کنیم.

---

### 4. تست‌ها

```js
it("should have a and b property", () => {
  expect(calculator).toHaveProperty("a");
  expect(calculator).toHaveProperty("b");
});

it("add", () => {
  expect(calculator.add()).toBe(15); // 10 + 5
});

it("sub", () => {
  expect(calculator.sub()).toBe(5); // 10 - 5
});

it("mul", () => {
  expect(calculator.mul()).toBe(50); // 10 * 5
});

it("div", () => {
  expect(calculator.div()).toBe(2); // 10 / 5
});
```

* تست اول مطمئن میشه کلاس درست ساخته شده (`a` و `b` وجود دارن).
* هر متد جداگانه تست شده → این باعث میشه وقتی یه متد خراب باشه، فقط همون تست fail بشه.

---

### 5. چی یاد گرفتی؟

1. فرق فانکشن و کلاس → وقتی چندتا رفتار به هم مرتبط هستن، بهتره کلاس بسازی.
2. استفاده از **beforeEach** برای ساختن instance و جلوگیری از تکرار کد.
3. تست کردن هر متد کلاس جدا جدا.
4. تست property‌ها (وجود `a` و `b`) و تست رفتار (چه خروجی باید بده).

---

### 6. ایده برای تمرین بیشتر

* تست کن وقتی `b = 0` باشه، `div()` چه نتیجه‌ای میده (در جاوااسکریپت `Infinity` برمی‌گردونه).
* یه متد جدید `pow()` اضافه کن (مثلا `a^b`) و براش تست بنویس.
* برای ورودی‌های منفی هم تست بنویس.

---

📌 این اپیزود بهت یاد داد چطور کلاس بسازی، متدهاشو تست کنی و از Jest برای چک کردن رفتارهای مختلف استفاده کنی.
یعنی یک قدم نزدیک‌تر شدی به **تست‌نویسی شی‌ءگرا (OOP Testing)**.