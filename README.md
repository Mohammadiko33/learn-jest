## **Jest در جاوااسکریپت**

### **تعریف**

Jest یک فریم‌ورک تست (Testing Framework) برای جاوااسکریپت است که توسط شرکت **Facebook** توسعه یافته است. این ابزار برای تست برنامه‌های **React** و **Node.js** بسیار محبوب است. هدف Jest این است که توسعه‌دهندگان بتوانند کدهای خود را به‌صورت **خودکار و قابل اعتماد** تست کنند.

### **ویژگی‌های مهم Jest**

1. **آسان برای استفاده:** با دستور ساده می‌توان تست نوشت و اجرا کرد.
2. **شبیه‌سازی (Mocking):** امکان شبیه‌سازی توابع و ماژول‌ها را فراهم می‌کند.
3. **پوشش کد (Code Coverage):** گزارش می‌دهد که چه بخش‌هایی از کد شما تست شده‌اند.
4. **تست واحد و انتگرال:** هم برای تست واحد (Unit Test) و هم برای تست‌های ترکیبی مناسب است.

---

### **نحوه نصب Jest**

برای نصب Jest در پروژه Node.js:

```bash
npm install --save-dev jest
```

در فایل `package.json` می‌توانیم اسکریپت زیر را اضافه کنیم:

```json
"scripts": {
  "test": "jest"
}
```

---

### **مثال ساده**

فرض کنید یک فایل داریم به نام `sum.js`:

```javascript
function sum(a, b) {
  return a + b;
}

module.exports = sum;
```

یک فایل تست به نام `sum.test.js` می‌نویسیم:

```javascript
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

**توضیح کد تست:**

* `test` یک تابع است که یک **توضیح تست** و یک **تابع تست** می‌گیرد.
* `expect` مقداری که برگردانده شده را با **مقدار مورد انتظار** مقایسه می‌کند.
* `toBe` برای مقایسه دقیق استفاده می‌شود.

برای اجرای تست، کافی است دستور زیر را در ترمینال وارد کنید:

```bash
npm test
```

---

### **نتیجه**

Jest باعث می‌شود توسعه‌دهندگان:

* راحت‌تر خطاها را پیدا کنند،
* اطمینان حاصل کنند که تغییرات جدید، کد قبلی را خراب نکرده‌اند،
* و با سرعت بیشتری کد با کیفیت بالا تولید کنند.

---

حتماً! من متن شما را به یک نسخه **ساده، روان و خلاصه** تبدیل کردم:

---

# **انواع تست خودکار در برنامه‌نویسی**

در تست خودکار سه نوع اصلی داریم:

1. **Unit Test (تست واحد)**
2. **Integration Test (تست یکپارچگی)**
3. **End-to-End Test (تست انتها به انتها)**

---

## **1. Unit Test (تست واحد)**

* تمرکز روی **یک بخش کوچک از برنامه** مثل یک تابع یا کلاس است.
* **بدون وابستگی به منابع خارجی** مثل دیتابیس یا API انجام می‌شود.
* اگر تابعی نیاز به داده از بیرون دارد، آن بخش را با **Mock** شبیه‌سازی می‌کنیم.
* **مزیت:** سریع و راحت اجرا می‌شود؛ می‌توان صدها تست را در چند ثانیه اجرا کرد.
* **معایب:** چون منابع خارجی تست نمی‌شوند، **اعتماد کامل نمی‌دهند**.

**خلاصه:** یونیت تست یعنی تست کردن همان بخش کوچک برنامه، بدون اتصال به چیزی خارج از آن.

---

## **2. Integration Test (تست یکپارچگی)**

* برخلاف یونیت تست، این تست **با منابع خارجی واقعی** کار می‌کند، مثل دیتابیس یا سرویس‌های دیگر.
* **زمان‌برتر** است، چون نیاز به خواندن و نوشتن داده از منابع واقعی دارد.
* **مزیت:** اعتماد بیشتری نسبت به عملکرد واقعی برنامه می‌دهد.
* نکته مهم: فقط داشتن چند کلاس باهم کافی نیست؛ شرط این تست **ارتباط با منابع خارجی** است.

---

## **3. End-to-End Test (تست انتها به انتها)**

* برنامه را **از طریق رابط کاربری واقعی** تست می‌کند، درست مثل یک کاربر واقعی.
* شامل بالا آوردن برنامه، ورود اطلاعات، احراز هویت، پر کردن فرم‌ها و دریافت نتیجه است.
* **بیشترین اعتماد را دارد**، اما **خیلی زمان‌بر است**.
* معمولاً با ابزارها و افزونه‌های مخصوص تست رابط کاربری انجام می‌شود.

---

# **چه زمانی از هر نوع تست استفاده کنیم؟**

* **Unit Test (تست واحد):**

  * مناسب برای **منطق برنامه** است.
  * برای بررسی **شرط‌ها، حلقه‌ها و الگوریتم‌های پیچیده** بسیار خوب عمل می‌کند.
  * اگر بخشی از برنامه دارای **منطق الگوریتمی** است، حتماً باید با یونیت تست پوشش داده شود.

* **Integration Test (تست یکپارچگی):**

  * برای بخش‌هایی که الگوریتم خاصی ندارند،
  * یا فقط **خواندن/نوشتن اطلاعات از دیتابیس** انجام می‌دهند،
  * استفاده می‌شود.
  * این تست باعث اطمینان از عملکرد واقعی با منابع خارجی می‌شود.

* **End-to-End Test (تست انتها به انتها):**

  * برای اطمینان بیشتر، می‌توان **مقداری E2E** هم اضافه کرد.
  * این تست تضمین می‌کند برنامه در **کل مسیر واقعی** درست کار می‌کند.

**خلاصه:**

> الگوریتم‌ها → یونیت تست

> دیتابیس و منابع خارجی → اینترگریشن تست

> مسیر کامل کاربر → اند تو اند تست

---

حتماً! اول یک توضیح ساده درباره‌ی تستی که نوشتی می‌دهم و بعد متدهای آخر را با مثال کوتاه و ساده شرح می‌دهم.

---


```javascript
const gte = require("../app")
```

این خط تابع `gte` را از فایل `app.js` وارد می‌کند.

```javascript
test("gte - should return true if a is grater than b", () => {
    const res = gte(10,9);
    expect(9).toBe(8);
});
```

* `test` یک تست جدید تعریف می‌کند.
* `expect` برای **مقایسه نتیجه واقعی با مقدار مورد انتظار** استفاده می‌شود.
* نکته: در اینجا مقادیر `expect(9).toBe(8)` و `expect(6).toBe(7)` اشتباه هستند، چون همیشه **این تست‌ها شکست می‌خورند**. درستش باید مثل این باشد:

```javascript
expect(res).toBe(true);  // وقتی 10 >= 9
```

---

## **متدهای Jest و مثال ساده**

### 1. `.toBeNull()`

چک می‌کند مقدار **null** باشد.

```javascript
expect(null).toBeNull();
```

### 2. `.toBeUndefined()`

چک می‌کند مقدار **undefined** باشد.

```javascript
let a;
expect(a).toBeUndefined();
```

### 3. `.toBeDefined()`

چک می‌کند مقدار **تعریف شده** باشد (نه undefined).

```javascript
let a = 5;
expect(a).toBeDefined();
```

### 4. `.toBeTruthy()`

چک می‌کند مقدار **در شرط if درست** باشد.

```javascript
expect(true).toBeTruthy();
expect(1).toBeTruthy();
```

### 5. `.toBeFalsy()`

چک می‌کند مقدار **در شرط if غلط** باشد.

```javascript
expect(false).toBeFalsy();
expect(0).toBeFalsy();
```

### 6. `.toBeGreaterThan(number)`

چک می‌کند مقدار بزرگ‌تر از عدد داده شده باشد.

```javascript
expect(10).toBeGreaterThan(5);
```

### 7. `.toBeGreaterThanOrEqual(number)`

چک می‌کند مقدار **بزرگ‌تر یا مساوی** عدد باشد.

```javascript
expect(10).toBeGreaterThanOrEqual(10);
```

### 8. `.toBeLessThan(number)`

چک می‌کند مقدار کوچک‌تر از عدد باشد.

```javascript
expect(5).toBeLessThan(10);
```

### 9. `.toBeLessThanOrEqual(number)`

چک می‌کند مقدار **کمتر یا مساوی** عدد باشد.

```javascript
expect(5).toBeLessThanOrEqual(5);
```

### 10. `.toBeCloseTo(number, numDigits?)`

چک می‌کند مقدار **تقریباً برابر** عدد باشد (برای اعداد اعشاری).

```javascript
expect(0.1 + 0.2).toBeCloseTo(0.3);
```
